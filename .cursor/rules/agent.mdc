---
alwaysApply: true
description: R√®gle pour g√©rer la cr√©ation automatique de t√¢ches dans la roadmap centralis√©e lorsque des t√¢ches sont identifi√©es pour le futur
---

# R√®gle Agent ‚Äî Gestion de la Roadmap Centralis√©e üìã

## Objectif

Cette r√®gle t'explique **quand** et **comment** cr√©er des t√¢ches dans la roadmap centralis√©e (`.cursor/agents/roadmap.yaml`) lorsque tu identifies des travaux √† faire dans le futur ou qui peuvent √™tre effectu√©s en parall√®le.

## Principe Fondamental

Le syst√®me de roadmap permet de :
- Coordonner plusieurs agents Cursor travaillant en parall√®le
- Garder une trace centralis√©e de toutes les t√¢ches √† faire
- Permettre √† chaque agent de consulter le travail accompli par les autres via les fichiers de r√©sultats
- Faciliter le saut d'un chat √† l'autre tout en gardant le contexte

## Quand Cr√©er une T√¢che dans la Roadmap

Tu **DOIS** cr√©er une t√¢che dans la roadmap lorsque :

1. **T√¢che mentionn√©e pour le futur** : Une t√¢che est mentionn√©e ou identifi√©e qui ne sera **certainement pas** effectu√©e dans le chat actuel
2. **T√¢che parall√©lisable** : Une t√¢che peut √™tre effectu√©e en parall√®le avec d'autres travaux en cours
3. **D√©pendance future** : Une t√¢che doit √™tre faite plus tard mais d√©pend de travaux actuels

Tu **NE DOIS PAS** cr√©er de t√¢che si :
- La t√¢che sera effectu√©e imm√©diatement dans le chat actuel
- La t√¢che est d√©j√† dans la roadmap
- La t√¢che est trop vague pour √™tre utile (il faut un minimum de contexte)

## Cr√©ation Autonome de T√¢ches

### Principe Fondamental

Tu **DOIS** cr√©er des t√¢ches de mani√®re **autonome et automatique** lorsqu'au cours de ton travail (planification, discussion avec l'utilisateur, exploration du code, impl√©mentation), tu identifies une t√¢che qui correspond aux crit√®res de la section "Quand Cr√©er une T√¢che dans la Roadmap".

Ce comportement est **identique** √† celui de la commande `/task`, mais d√©clench√© de mani√®re autonome sans intervention de l'utilisateur. La diff√©rence critique est que cette cr√©ation est **non-bloquante** : tu cr√©es la t√¢che puis reprends imm√©diatement ton travail comme si de rien n'√©tait.

### Comportement Requis

Lorsque tu identifies une t√¢che future pendant ton travail, tu **DOIS** :

1. **D√©tecter automatiquement** :
   - Pendant l'√©laboration d'un plan, tu identifies une d√©pendance ou un travail futur n√©cessaire
   - Pendant une discussion avec l'utilisateur, une t√¢che future est mentionn√©e ou sugg√©r√©e
   - Pendant l'exploration du code, tu d√©couvres un probl√®me ou une opportunit√© qui n√©cessite un travail futur
   - Pendant l'impl√©mentation, tu r√©alises qu'une am√©lioration ou un refactoring devrait √™tre fait plus tard

2. **Cr√©er la t√¢che silencieusement** :
   - Suivre **exactement** le processus d√©crit dans la section "Comment Cr√©er une T√¢che ‚Äî Processus Complet" (√âtapes 1 √† 5)
   - Ex√©cuter toutes les √©tapes sans pause ni interruption
   - Ne pas mentionner la cr√©ation de la t√¢che √† l'utilisateur sauf si :
     - La cr√©ation √©choue (fail-fast avec message d'erreur clair)
     - Le contexte n√©cessite explicitement de mentionner cette t√¢che pour la compr√©hension

3. **Reprendre imm√©diatement** :
   - Apr√®s avoir cr√©√© et sauvegard√© la t√¢che dans la roadmap
   - Continuer exactement l√† o√π tu t'√©tais arr√™t√© dans ton travail pr√©c√©dent
   - Reprendre tes todos en cours comme si rien ne s'√©tait pass√©
   - La t√¢che cr√©√©e sera trait√©e par un autre agent (via `/agent`) plus tard

### Exemples Concrets

**Exemple 1 ‚Äî Pendant un plan** :
Tu es en train de planifier l'impl√©mentation d'un syst√®me d'authentification. Pendant l'analyse, tu d√©couvres que les performances pourraient √™tre optimis√©es, mais cela n√©cessite une exploration approfondie qui sort du scope actuel.
‚Üí **Action** : Cr√©er automatiquement la t√¢che "Optimiser les performances d'authentification" et l'ins√©rer au bon endroit dans le tableau selon ses d√©pendances, puis continuer la planification de l'authentification comme si de rien n'√©tait.

**Exemple 2 ‚Äî Pendant une discussion** :
L'utilisateur mentionne "on pourrait aussi am√©liorer le syst√®me de cache plus tard" pendant que tu travailles sur une autre fonctionnalit√©.
‚Üí **Action** : Cr√©er automatiquement la t√¢che "Am√©liorer le syst√®me de cache" en capturant le contexte de la discussion, puis reprendre le travail sur la fonctionnalit√© en cours.

**Exemple 3 ‚Äî Pendant l'exploration** :
Tu explores le codebase pour comprendre comment fonctionne un module. Tu d√©couvres du code dupliqu√© qui devrait √™tre refactoris√©, mais ce n'est pas l'objectif actuel.
‚Üí **Action** : Cr√©er automatiquement la t√¢che "Refactoriser le code dupliqu√© dans [module]" avec les fichiers pertinents list√©s, puis continuer ton exploration initiale.

**Exemple 4 ‚Äî Pendant l'impl√©mentation** :
Tu impl√©mentes une nouvelle fonctionnalit√© et tu r√©alises qu'un test d'int√©gration complet serait n√©cessaire, mais cela d√©passe le scope de l'impl√©mentation actuelle.
‚Üí **Action** : Cr√©er automatiquement la t√¢che "Cr√©er des tests d'int√©gration pour [fonctionnalit√©]" en r√©f√©ren√ßant les fichiers modifi√©s, puis continuer l'impl√©mentation.

### Diff√©rence avec `/task`

La commande `/task` est utilis√©e par l'utilisateur pour cr√©er explicitement une t√¢che. Les comportements sont techniquement identiques (m√™me processus de cr√©ation), mais diff√®rent sur les points suivants :

**Cr√©ation autonome (agent.mdc)** :
- **D√©clench√© automatiquement** par l'agent sans intervention utilisateur
- **Silencieux** : pas de message de confirmation sauf en cas d'erreur
- **Non-bloquant** : aucun changement de focus ou d'interruption du travail

**Commande `/task`** :
- **Interruption obligatoire et imm√©diate** : suspend TOUT travail en cours pour √™tre trait√©e
- **Avec confirmation** : `‚úÖ T√¢che ajout√©e (task-{id})` pour informer l'utilisateur
- **Reprise imm√©diate** : l'agent reprend le travail pr√©c√©dent apr√®s confirmation

### Gestion des Erreurs

Si la cr√©ation de la t√¢che √©choue (fichier roadmap.yaml invalide, d√©pendance manquante, etc.) :
- **√âchouer explicitement** avec un message d'erreur clair √† l'utilisateur
- Apr√®s avoir inform√© de l'erreur, **reprendre n√©anmoins** ton travail pr√©c√©dent
- Ne pas bloquer ind√©finiment sur l'erreur de cr√©ation de t√¢che

## Comment Cr√©er une T√¢che ‚Äî Processus Complet

### √âtape 1 : Identifier les M√©tadonn√©es

Avant de cr√©er la t√¢che, identifier :

- **Titre descriptif** : Un titre clair et actionnable (ex: "Optimiser les performances d'authentification")
  - **IMPORTANT** : Le titre doit √™tre unique pour √©viter les collisions de noms de fichiers
- **Description courte** : G√©n√©rer une description de 3 phrases maximum qui r√©sume l'objectif de la t√¢che. Cette description sera utilis√©e pour l'analyse automatique des d√©pendances avec les autres t√¢ches
- **D√©pendances** : Liste des IDs de t√¢ches qui doivent √™tre termin√©es avant (peut √™tre vide)
- **Position dans le tableau** : La position dans le tableau `tasks` du fichier `roadmap.yaml` d√©finit l'ordre de traitement. La premi√®re t√¢che du tableau est la plus urgente, la derni√®re est la moins urgente. Lors de l'insertion, placer la nouvelle t√¢che selon ses d√©pendances (apr√®s toutes les t√¢ches dont elle d√©pend) ou au d√©but si elle n'a pas de d√©pendances.
- **Contexte** : Pourquoi cette t√¢che existe, ce qui a √©t√© d√©couvert, etc.

### √âtape 2 : G√©n√©rer le Nom de Fichier

1. Convertir le titre en format kebab-case (ex: "Optimiser les performances" ‚Üí "optimiser-performances")
2. **IMPORTANT** : V√©rifier que le titre est unique dans la roadmap pour √©viter les collisions de noms de fichiers
3. Nom du fichier de t√¢che : `{titre-kebab-case}.md`
4. Nom du fichier de r√©sultat : `rapport-{titre-kebab-case}.md`

Exemple :
- Titre : "Supprimer tous les serveurs MCP obsol√®tes"
- Fichier t√¢che : `supprimer-tous-les-serveurs-mcp-obsoletes.md`
- Fichier r√©sultat : `rapport-supprimer-tous-les-serveurs-mcp-obsoletes.md`

### √âtape 3 : Cr√©er le Fichier de T√¢che

Cr√©er le fichier `.cursor/agents/{nom-fichier-tache}.md` avec **exactement** ce format :

```markdown
## Contexte

[√âcrire en fran√ßais une histoire narrative expliquant pourquoi cette t√¢che existe. Mentionner ce qui a √©t√© d√©couvert, les probl√®mes identifi√©s, ou les opportunit√©s qui justifient cette t√¢che. Utiliser un langage naturel et narratif, sans trop de d√©tails techniques.]

## Objectif

[√âcrire en fran√ßais une description vague mais claire de ce qui doit √™tre accompli. L'objectif doit √™tre exploratoire, pas trop pr√©cis. Accepter le vague - la pr√©cision viendra avec la discussion lors de l'impl√©mentation.]

Exemple : "Explorer la possibilit√© d'optimiser le syst√®me d'authentification pour am√©liorer les performances sous charge" plut√¥t que "Configurer un cache Redis avec param√®tres sp√©cifiques X, Y, Z".

## Fichiers Concern√©s

[√âcrire en fran√ßais. Lister DEUX cat√©gories de fichiers/dossiers/recherches :]

### Du travail effectu√© pr√©c√©demment :
- `chemin/vers/fichier1` : [Expliquer ce qui a √©t√© fait ou d√©couvert dans ce fichier]
- `chemin/vers/fichier2` : [Expliquer ce qui est pertinent]

### Fichiers potentiellement pertinents pour l'exploration :
- `chemin/vers/fichier3` : [Expliquer pourquoi ce fichier pourrait √™tre important]
- `chemin/vers/dossier/` : [Expliquer la pertinence]

### Recherches √† effectuer :
- Recherche s√©mantique : "Comment sont g√©r√©es les performances dans le codebase ?"
- Recherche web : "Meilleures pratiques pour optimiser l'authentification JWT"
- Documentation : Lire `README.md` et `documentation/architecture.md`

### Fichiers de r√©sultats d'autres agents (si pertinents) :
- `.cursor/agents/rapport-tache-precedente.md` : [Expliquer pourquoi ce rapport est utile]

**Fichier output pour le rapport final :**
- `.cursor/agents/rapport-{titre-kebab-case}.md`

## Instructions de Collaboration

[√âcrire en fran√ßais. **OBLIGATOIRE ET CRITIQUE** : Cette section doit √™tre extr√™mement directive et imp√©rative. Tu DOIS sp√©cifier que l'agent :]

- **EST INTERDIT** de commencer √† impl√©menter quoi que ce soit imm√©diatement
- **DOIT** lire EXHAUSTIVEMENT tous les fichiers list√©s dans "Fichiers Concern√©s" avant toute action
- **DOIT** effectuer toutes les recherches s√©mantiques et web mentionn√©es
- **DOIT** lire le README et toute documentation pertinente
- **DOIT** atteindre une compr√©hension approfondie du contexte et du projet avant toute discussion
- **DOIT** discuter avec l'utilisateur pour clarifier les attentes pr√©cises, poser des questions sur les contraintes techniques, et √©tablir un plan d'action d√©taill√© ensemble
- **DOIT TOUJOURS** cr√©er le fichier de rapport final dans le fichier output mentionn√© apr√®s avoir termin√© (voir section "Instructions pour les Rapports Finaux")
- Seulement APR√àS avoir compl√©t√© cette exploration exhaustive et cette planification collaborative, peut commencer toute impl√©mentation

Emphasizer que l'exploration est OBLIGATOIRE, pas optionnelle.
```

**IMPORTANT** : Tous les fichiers de t√¢ches doivent suivre **exactement** ce format avec les 4 sections obligatoires.

### √âtape 4 : Ajouter l'Entr√©e dans roadmap.yaml

Lire le fichier `.cursor/agents/roadmap.yaml` et ajouter une nouvelle entr√©e dans la liste `tasks` :

```yaml
- id: "task-{unique-id}"  # G√©n√©rer un ID unique (ex: task-1, task-2, etc.)
  title: "Titre descriptif de la t√¢che"
  description: "Description courte de l'objectif de la t√¢che (3 phrases max)"  # Utilis√© pour l'analyse de d√©pendances
  state: "todo"  # "todo" ou "in-progress"
  dependencies: []  # Liste d'IDs de t√¢ches ou []
  dependencies-results: []  # Liste de noms de fichiers de rapports de d√©pendances termin√©es (format: liste de strings avec noms de fichiers uniquement, ex: ["rapport-tache-1.md"])
  task_file: "{nom-fichier-tache}.md"
  output_file: "rapport-{nom-fichier-tache}.md"
  deadline: null  # Optionnel
```

**Ordre d'insertion** :
- La position dans le tableau `tasks` d√©finit l'ordre de traitement : la premi√®re t√¢che est la plus urgente, la derni√®re est la moins urgente
- Si la nouvelle t√¢che a des d√©pendances : ins√©rer apr√®s toutes les t√¢ches dont elle d√©pend (identifier la position la plus basse de ses d√©pendances et ins√©rer juste apr√®s)
- Si la nouvelle t√¢che n'a pas de d√©pendances : ins√©rer au d√©but du tableau (premi√®re position)

**G√©n√©ration d'ID unique** :
- Si le fichier roadmap.yaml existe d√©j√†, lire toutes les t√¢ches existantes
- Identifier le plus grand ID num√©rique utilis√© (ex: si task-5 existe, le prochain est task-6)
- Utiliser le format `task-{numero}` pour garantir l'unicit√©

**Validation** :
- V√©rifier que le fichier `task_file` existe (que tu viens de cr√©er)
- V√©rifier que les d√©pendances mentionn√©es existent dans la roadmap (si des d√©pendances sont sp√©cifi√©es)
- Si validation √©choue ‚Üí **√âCHOUER EXPLICITEMENT** avec un message clair

**dependencies-results** :
- Ce champ contient une liste de noms de fichiers (sans chemin, ex: `["rapport-tache-1.md"]`) r√©f√©ren√ßant les rapports de t√¢ches d√©pendantes d√©j√† termin√©es
- Lorsqu'une t√¢che d√©pendante est termin√©e, `/agent` (√©tape 2.0) et `/clean` ajoutent automatiquement son `output_file` dans les `dependencies-results` des t√¢ches qui en d√©pendent
- Ces fichiers sont lus automatiquement lors du chargement du contexte d'une t√¢che via `/agent` pour donner acc√®s aux r√©sultats des d√©pendances

### √âtape 5 : Sauvegarder

Sauvegarder le fichier `roadmap.yaml` avec la nouvelle entr√©e ajout√©e.

## Exemple Complet

Supposons que tu travailles sur l'authentification et d√©couvres des probl√®mes de performance. Tu veux cr√©er une t√¢che pour optimiser plus tard.

**√âtape 1 - M√©tadonn√©es** :
- Titre : "Optimiser les performances d'authentification"
- Description : "Am√©liorer le temps de r√©ponse du syst√®me d'authentification en optimisant les requ√™tes de base de donn√©es et en impl√©mentant un cache pour les tokens JWT"
- D√©pendances : []
- Position : Au d√©but du tableau (pas de d√©pendances)
- Contexte : Probl√®mes de performance d√©couverts lors des tests

**√âtape 2 - Noms de fichiers** :
- Fichier t√¢che : `optimiser-performances-auth.md`
- Fichier r√©sultat : `rapport-optimiser-performances-auth.md`

**√âtape 3 - Cr√©er le fichier de t√¢che** :
- Cr√©er `.cursor/agents/optimiser-performances-auth.md` avec les 4 sections (v√©rifier l'unicit√© du titre)

**√âtape 4 - Ajouter dans roadmap.yaml** :
```yaml
- id: "task-1"
  title: "Optimiser les performances d'authentification"
  description: "Am√©liorer le temps de r√©ponse du syst√®me d'authentification en optimisant les requ√™tes de base de donn√©es et en impl√©mentant un cache pour les tokens JWT"
  state: "todo"
  dependencies: []
  dependencies-results: []
  task_file: "optimiser-performances-auth.md"
  output_file: "rapport-optimiser-performances-auth.md"
  deadline: null
```

## Instructions pour les Rapports Finaux ‚Äî CRITIQUE ‚ö†Ô∏è

**CRITIQUE ABSOLUE** : Quand tu travailles sur une t√¢che s√©lectionn√©e via `/agent`, tu **DOIS TOUJOURS** cr√©er le fichier de rapport final √† la fin de ton chat, m√™me si la t√¢che n'a pas √©t√© compl√©t√©e avec succ√®s. C'est ce fichier qui permet aux autres agents de d√©tecter que la t√¢che est termin√©e.

### Pourquoi le Rapport est Critique

Le syst√®me de d√©tection des t√¢ches termin√©es fonctionne **uniquement** via l'existence du fichier `output_file` :

1. **D√©tection automatique** : Lorsqu'un agent ex√©cute `/agent`, l'√©tape 2.0 v√©rifie toutes les t√¢ches avec `state: "in-progress"` et d√©tecte qu'elles sont termin√©es si leur fichier `output_file` existe dans `.cursor/agents/`
2. **Nettoyage automatique** : Une fois d√©tect√©e comme termin√©e, la t√¢che est automatiquement retir√©e de la roadmap, ses d√©pendances sont mises √† jour, et les fichiers orphelins sont nettoy√©s
3. **Commandes concern√©es** : Ce m√©canisme est utilis√© par `/agent` (√©tape 2.0) et `/clean` pour maintenir l'hygi√®ne de la roadmap

**Cons√©quence grave si le rapport n'est pas cr√©√©** :
- La t√¢che restera bloqu√©e en `state: "in-progress"` ind√©finiment
- Les t√¢ches qui en d√©pendent ne pourront jamais √™tre s√©lectionn√©es
- La roadmap se bloquera progressivement avec des t√¢ches "fant√¥mes" jamais termin√©es

### Cr√©ation Obligatoire du Rapport

√Ä la fin d'un chat, quand tu as termin√© ton travail sur une t√¢che s√©lectionn√©e via `/agent`, tu **DOIS TOUJOURS** cr√©er le fichier de rapport final :

- **Fichier** : `.cursor/agents/{output_file}` (o√π `output_file` est d√©fini dans la t√¢che avec `state: "in-progress"`)
- **Cette √©tape est OBLIGATOIRE** car c'est ce qui permet √† d'autres agents de d√©tecter que la t√¢che est termin√©e (√©tape 2.0 de `/agent` ou `/clean`)
- Le rapport marque que la t√¢che est termin√©e, qu'elle soit r√©ussie ou non

### Contenu du Rapport selon le R√©sultat

- **Si succ√®s** : R√©sum√© du travail effectu√©, d√©cisions prises, fichiers modifi√©s, r√©sultats obtenus
- **Si √©chec/probl√®me** : Explication du probl√®me rencontr√©, raisons de l'√©chec, travaux partiels effectu√©s, contexte utile

### Gestion des √âchecs

Si la t√¢che a rencontr√© un probl√®me et n√©cessite un travail suppl√©mentaire :

1. Tu **DOIS** cr√©er le rapport (pour marquer la fin de la t√¢che actuelle)

2. **ET** cr√©er une nouvelle t√¢che dans la roadmap (comme s'il invoquait `/task`) pour documenter :
   - Le probl√®me rencontr√©
   - Les travaux partiels effectu√©s
   - Les prochaines √©tapes n√©cessaires

3. **Gestion des d√©pendances** : Lors de la cr√©ation de la nouvelle t√¢che :
   - Identifier les t√¢ches qui peuvent √™tre d√©bloqu√©es (celles dont la d√©pendance sur la t√¢che originale peut √™tre supprim√©e car le travail partiel les d√©bloque)
   - Identifier les t√¢ches qui restent bloqu√©es (celles qui d√©pendent toujours de la nouvelle t√¢che cr√©√©e)
   - Mettre √† jour les d√©pendances en cons√©quence

4. La nouvelle t√¢che doit r√©f√©rencer la t√¢che originale dans son contexte pour expliquer le lien

### Int√©gration dans les Plans d'Impl√©mentation

Quand tu cr√©es un plan d'impl√©mentation pour une t√¢che s√©lectionn√©e via `/agent`, tu **DOIS** inclure comme **derni√®re √©tape OBLIGATOIRE** :

- Cr√©er le fichier de rapport final : `.cursor/agents/{output_file}`
- Cette √©tape est **OBLIGATOIRE** et doit √™tre ex√©cut√©e √† la fin du chat, que la t√¢che soit r√©ussie ou non
- **Rappel** : Sans ce fichier, la t√¢che ne sera jamais d√©tect√©e comme termin√©e et bloquera la roadmap

## Points d'Attention

- **Fail-Fast** : Si roadmap.yaml n'existe pas, le cr√©er avec la structure de base (`version: "1.0"`, `tasks: []`)
- **State par d√©faut** : Toutes les nouvelles t√¢ches doivent avoir `state: "todo"` par d√©faut
- **Format coh√©rent** : Tous les fichiers de t√¢ches doivent suivre exactement le m√™me format
- **Validation** : Valider que les d√©pendances existent avant d'ajouter la t√¢che
- **Fran√ßais** : Tout le contenu des fichiers de t√¢ches doit √™tre en fran√ßais
- **Unicit√©** : Garantir que les IDs de t√¢ches sont uniques
- **Rapport obligatoire** : Le fichier de rapport doit TOUJOURS √™tre cr√©√© √† la fin d'un chat pour marquer la fin de la t√¢che. C'est le seul m√©canisme de d√©tection des t√¢ches termin√©es utilis√© par `/agent` et `/clean`

## Int√©gration avec le Workflow

Cette r√®gle fonctionne en compl√©ment de :
- La commande `/agent` qui permet de s√©lectionner et traiter une t√¢che (notamment l'√©tape 2.0 de nettoyage des t√¢ches termin√©es via d√©tection des fichiers output)
- La commande `/clean` qui nettoie les t√¢ches in-progress via la m√™me logique de d√©tection
- Les autres r√®gles existantes (peut √™tre combin√©e avec `agent.mdc`, `debug.mdc`, etc.)

Quand tu identifies une t√¢che future, cr√©e-la imm√©diatement dans la roadmap plut√¥t que de la noter mentalement ou de l'oublier.
